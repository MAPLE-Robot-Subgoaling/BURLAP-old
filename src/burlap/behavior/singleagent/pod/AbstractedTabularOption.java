package burlap.behavior.singleagent.pod;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;

import burlap.behavior.singleagent.Policy.ActionProb;
import burlap.behavior.singleagent.options.Option;
import burlap.behavior.statehashing.StateHashFactory;
import burlap.behavior.statehashing.StateHashTuple;
import burlap.oomdp.core.ObjectClass;
import burlap.oomdp.core.State;
import burlap.oomdp.singleagent.Action;
import burlap.oomdp.singleagent.GroundedAction;

/**
 * This class acts as an option-based wrapper for an AbstractedTabularPolicy
 * object to be used in an OO-MDP. Given initialization in some domain, the
 * option abstracts its provided policy relative to the target domain. Allows
 * for stochastic option termination and bookkeeping to prevent a cyclic
 * trajectory within the option's execution.
 * 
 * @author Nicholas Haltmeyer
 * 
 */
public class AbstractedTabularOption extends Option {
    /**
     * The original policy.
     */
    private Map<StateHashTuple, GroundedAction> policy;
    /**
     * The newly abstracted policy relative to some target.
     */
    private Map<StateHashTuple, List<GroundedAction>> abstractedPolicy;
    /**
     * The combinations of objects. Generated by means of the GCG.
     */
    private List<List<ObjectClass>> ocombs;
    /**
     * The specific combination to use (manually set).
     */
    private List<ObjectClass> combToUse;
    /**
     * The greatest common generalization.
     */
    private Map<ObjectClass, Integer> gcg;
    /**
     * The object used to properly transform state objects into state hash
     * tuples.
     */
    private StateHashFactory hf;
    /**
     * The set of primitive actions valid within the target domain.
     */
    private List<Action> actions;
    /**
     * The set of states currently visited during this execution.
     */
    private Set<StateHashTuple> visited;
    /**
     * A random object for when dice rolls are necessary.
     */
    private Random rand;
    /**
     * The option termination probability.
     */
    private double termProb;
    /**
     * Whether or not the abstraction has been generated yet. Used to reset
     * abstraction.
     */
    private boolean abstractionGenerated;
    /**
     * Whether or not to perform a weighted dice roll over all tied actions, or
     * to select the most common action.
     */
    private boolean roll;

    public AbstractedTabularOption(StateHashFactory hf,
	    Map<StateHashTuple, GroundedAction> policy, List<Action> actions,
	    double termProb, String name) {
	this(hf, policy, actions, termProb, true, null, name);
    }

    public AbstractedTabularOption(StateHashFactory hf,
	    Map<StateHashTuple, GroundedAction> policy, List<Action> actions,
	    double termProb, List<ObjectClass> combToUse, String name) {
	this(hf, policy, actions, termProb, true, combToUse, name);
    }

    public AbstractedTabularOption(StateHashFactory hf,
	    Map<StateHashTuple, GroundedAction> policy, List<Action> actions,
	    double termProb, boolean roll, List<ObjectClass> combToUse,
	    String name) {
	if (policy.isEmpty()) {
	    throw new IllegalArgumentException("Empty policy provided.");
	} else if (actions.isEmpty()) {
	    throw new IllegalArgumentException("No actions provided.");
	} else if (termProb > 1 || termProb < 0) {
	    throw new IllegalArgumentException(
		    "Invalid termination probability");
	}

	this.policy = policy;
	this.hf = hf;
	super.name = "AO-" + name;
	this.visited = new HashSet<StateHashTuple>();
	this.rand = new Random();
	this.actions = actions;
	this.abstractedPolicy = new HashMap<StateHashTuple, List<GroundedAction>>();
	this.gcg = new HashMap<ObjectClass, Integer>();
	this.ocombs = new ArrayList<List<ObjectClass>>();
	this.termProb = termProb;
	this.abstractionGenerated = false;
	this.roll = roll;
	this.combToUse = combToUse;
    }

    @Override
    public boolean isMarkov() {
	return true;
    }

    @Override
    public boolean usesDeterministicTermination() {
	return termProb == 0.;
    }

    @Override
    public boolean usesDeterministicPolicy() {
	return true;
    }

    @Override
    /**
     * The probability of the option terminating in the current state. This is determined by whether or not the option is defined and the value of {@link #termProb}.
     */
    public double probabilityOfTermination(State incoming, String[] params) {
	List<StateHashTuple> states = getAbstractedStates(incoming);
	GroundedAction ga = getActionFromAbstractions(states);

	if (ga == null || visited.contains(hf.hashState(incoming))) {
	    visited.clear();
	    return 1.;
	}

	return termProb;
    }

    @Override
    public void initiateInStateHelper(State s, String[] params) {
	// Nothing to do here
    }

    @Override
    public GroundedAction oneStepActionSelection(State incoming, String[] params) {
	List<StateHashTuple> states = getAbstractedStates(incoming);

	if (visited.contains(hf.hashState(incoming))) {
	    visited.clear();
	    return null;
	}

	visited.add(hf.hashState(incoming));
	return getActionFromAbstractions(states);
    }

    @Override
    public List<ActionProb> getActionDistributionForState(State incoming,
	    String[] params) {
	List<ActionProb> aprobs = new ArrayList<ActionProb>();
	GroundedAction ga = oneStepActionSelection(incoming, params);

	for (Action a : actions) {
	    if (a.equals(ga.action)) {
		// If the action selection is in the set of actions stored,
		// return 1.
		ActionProb p = new ActionProb(ga, 1.);
		aprobs.add(p);
	    } else {
		// Otherwise, return 0.
		ActionProb p = new ActionProb(ga, 0.);
		aprobs.add(p);
	    }
	}

	return aprobs;
    }

    @Override
    public boolean applicableInState(State incoming, String[] params) {
	if (visited.contains(hf.hashState(incoming))) {
	    visited.clear();
	    return false;
	}

	List<StateHashTuple> states = getAbstractedStates(incoming);
	return getActionFromAbstractions(states) != null;
    }

    /**
     * Gets the best action according to all possible abstractions. The value of
     * {@link #roll} determines whether or not this is the most common action,
     * or the action selected over a weight dice roll. This choice is cached for
     * later use.
     * 
     * @param states
     *            The states to consider.
     * @return The best action
     */
    private GroundedAction getActionFromAbstractions(List<StateHashTuple> states) {
	List<GroundedAction> gas = new ArrayList<GroundedAction>();
	List<StateHashTuple> definedFor = new ArrayList<StateHashTuple>();

	for (StateHashTuple state : states) {
	    if (!abstractedPolicy.containsKey(state)) {
		continue;
	    }

	    List<GroundedAction> curGAs = abstractedPolicy.get(state);
	    gas.addAll(curGAs);
	    definedFor.add(state);
	}

	GroundedAction ga = null;

	if (gas.size() > 0) {
	    if (gas.size() == 1) {
		return gas.get(0);
	    }

	    if (roll) {
		// Weighted dice roll for selection
		ga = gas.get(rand.nextInt(gas.size()));
	    } else {
		// Most common for selection
		Map<GroundedAction, Integer> weights = new HashMap<GroundedAction, Integer>();
		for (GroundedAction gac : gas) {
		    weights.put(gac,
			    weights.containsKey(gac) ? weights.get(gac) + 1 : 1);
		}

		int max = 0;
		for (Entry<GroundedAction, Integer> e : weights.entrySet()) {
		    if (e.getValue() > max) {
			ga = e.getKey();
			max = e.getValue();
		    }
		}
	    }

	    // After the selection is made, it is cached for the future
	    for (StateHashTuple state : definedFor) {
		List<GroundedAction> aList = new ArrayList<GroundedAction>();
		aList.add(ga);
		abstractedPolicy.put(state, aList);
	    }
	}

	return ga;
    }

    /**
     * Gets all possible abstractions of the incoming state.
     * 
     * @param incoming
     *            The state to be abstracted
     * @return The list of abstracted states
     */
    private List<StateHashTuple> getAbstractedStates(State incoming) {
	if (!abstractionGenerated) {
	    generateAbstraction(incoming);
	}

	List<StateHashTuple> states = new ArrayList<StateHashTuple>();

	if (combToUse != null) {
	    states.add(hf.hashState(AbstractedPolicyFactory.formState(incoming,
		    combToUse)));
	} else {
	    for (List<ObjectClass> ocomb : ocombs) {
		states.add(hf.hashState(AbstractedPolicyFactory.formState(
			incoming, ocomb)));
	    }
	}

	return states;
    }

    /**
     * Generates the abstraction to be used in the current domain.
     * 
     * @param incoming
     *            The state to abstract with respect to
     */
    private void generateAbstraction(State incoming) {
	State withRespectTo = policy.keySet().iterator().next().s;
	List<State> ss = new ArrayList<State>();
	ss.add(incoming);
	ss.add(withRespectTo);
	this.gcg = AbstractedPolicyFactory.greatestCommonGeneralization(ss);
	this.ocombs = AbstractedPolicyFactory.generateAllCombinations(gcg,
		withRespectTo);

	for (Entry<StateHashTuple, GroundedAction> e : policy.entrySet()) {
	    if (!actions.contains(e.getValue().action)) {
		// If the incoming action is not in the target domain's
		// actions space, omit it.
		continue;
	    }

	    // Map the action to the target domain
	    GroundedAction curGA = new GroundedAction(actions.get(actions
		    .indexOf(e.getValue().action)), e.getValue().params);

	    /*
	     * if (combToUse != null) { State newS = AbstractedPolicy
	     * .formState(e.getKey().s, combToUse);
	     * 
	     * List<GroundedAction> aList; if
	     * (!abstractedPolicy.containsKey(hf.hashState(newS))) { aList = new
	     * ArrayList<GroundedAction>(); aList.add(curGA);
	     * abstractedPolicy.put(hf.hashState(newS), aList); } else {
	     * abstractedPolicy.get(hf.hashState(newS)).add(curGA); } } else {
	     */
	    for (List<ObjectClass> ocomb : ocombs) {
		State newS = AbstractedPolicyFactory.formState(e.getKey().s,
			ocomb);
		List<GroundedAction> aList;
		if (!abstractedPolicy.containsKey(hf.hashState(newS))) {
		    aList = new ArrayList<GroundedAction>();
		    aList.add(curGA);
		    abstractedPolicy.put(hf.hashState(newS), aList);
		} else {
		    abstractedPolicy.get(hf.hashState(newS)).add(curGA);
		}
	    }
	    // }
	}

	abstractionGenerated = true;
    }

    /**
     * Resets the option for use in a new domain.
     */
    public void resetOption() {
	resetAbstraction();
	hf = null;
	actions = new ArrayList<Action>();
	visited.clear();
    }

    /**
     * Resets the abstraction for use in a new domain.
     */
    public void resetAbstraction() {
	abstractionGenerated = false;
	abstractedPolicy = new HashMap<StateHashTuple, List<GroundedAction>>();
	gcg = new HashMap<ObjectClass, Integer>();
	ocombs = new ArrayList<List<ObjectClass>>();
    }

    /**
     * Set {@link #hf}
     * 
     * @param hf
     *            The new hash factory
     */
    public void setHashFactory(StateHashFactory hf) {
	this.hf = hf;
    }

    /**
     * Set {@link #actions}
     * 
     * @param actions
     *            The new set of primitive actions
     */
    public void setActions(List<Action> actions) {
	if (actions.isEmpty()) {
	    throw new RuntimeException("No actions provided.");
	}

	this.actions = actions;
    }

    /**
     * Gets the number of elements in the tabular policy
     * 
     * @return {@link #policy.size()}
     */
    public int size() {
	return policy.size();
    }

    /**
     * Sets the value for {@link #roll}
     * 
     * @param roll
     *            T/F
     */
    public void setRoll(boolean roll) {
	this.roll = roll;
    }
}
